### Language of Grammar

$$S \to SbS|aSa|abT$$
$$T \to TbS| \varepsilon$$

Note that through equivalent formations the second rule collapses into $$T \to (bS)^*$$ which can be applied to the first rule $$S \to SbS|aSa|ab(bS)^*$$. Note also that it is possible to simplify: $$S \to SbS|aSa|ab$$ because $$\underline{ab}(bS)^* \to SbSbS \dots$$ (since the first occurrence of S is expanded as ab). As a result, we come to the following rule:
$$S \to SbS|aSa|ab$$

Let's build an automaton based on it.

```dot
digraph finite_state_machine {
    rankdir=LR;
    node [shape = circle];
    q0 [label="0"];
    q1 [label="1"];
    q2 [label="2", shape=doublecircle];

    start [shape=point];
    start -> q0;

    q0 -> q0 [label="a, Z₀/AZ₀"];
    q0 -> q0 [label="a, A/AA"];
    q0 -> q0 [label="a, B/A"];
    q0 -> q1 [label="b, A/ε"];
    q1 -> q1 [label="a, A/ε"];
    q1 -> q0 [label="b, x/B"];
    q1 -> q2 [label="ε, Z₀/Z₀"];

    labelloc="b";
    label="received automaton";
}
```


### Language of Grammar

$$
S \to aSbS\\
S \to a
$$

Note that
$$
S \to \underline{a} S \underline{ba}
$$
we can get
$$
S \to aSbS|\varepsilon
$$
we get the correct bracket sequence.

Thus, we will build an automaton for this grammar.

```dot
digraph finite_state_machine {
    rankdir=LR;
    node [shape = circle];
    q0 [label="0", shape=doublecircle];
    q1 [label="1"];
    q2 [label="2"];
    q3 [label="3"];
    q4 [label="4", shape=doublecircle];

    q0 -> q1 [label="a, Z₀/Z₀"];
    q1 -> q2 [label="a, x/Ax"];
    q1 -> q3 [label="b, A/ε"];
    q1 -> q4 [label="ε, Z₀/ε"];
    q2 -> q2 [label="a, x/Ax"];
    q2 -> q3 [label="b, A/ε"];
    q3 -> q1 [label="a"];

    labelloc="b";
    label="received automaton";
}
```
