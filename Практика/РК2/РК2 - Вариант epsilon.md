# 1. Язык синтаксически корректных вызовов функций на языке Рефал. Вызов функции заключается в угловые скобки, аргумент-выражение от имени функции отделяется пробелом, выражение может быть вызовом функции, конкатенацией двух выражений, выражением в скобках, строкой(в одинарных кавычках) или переменная. Внутри строки могут быть экранированные обратным слешем одинарные кавычки. Также обратным слешем внутри кавычек экранируется сам обратный слеш. 
Язык КС, так как задается КС грамматикой:
```
[S]         -> <[Name] [Expr]>
[Expr]      -> [E][Expr_Tail]
[Expr_Tail] -> [E][Expr_Tail] | epsilon
[E]         -> ([Expr]) | "[String]" | [Name] | [S]
[String]    -> \w [String] | \ [Special] [String] | epsilon
[Special]   -> \ | "
[Name]      -> \w [Name_Tail]
[Name_Tail] -> \w [Name_Tail] | epsilon
```

Построенная грамматика является LL(1) => язык **детерминированный КС**.

**Префикс-свойство выполняется** так как требуется уравновешанность угловых скобок. То есть если слово `<w>` является префиксом другого слова, то после закрывающей угловой скобки должно идти еще что-то, что не возможно по условиям грамматики.

Проверка на VPL
Неформальное доказательство
Основной проблемой в том, чтобы язык был VPL является строки в двойных кавычках, так как там допускается наличие каких угодно символов, в том числе и открывающих и закрывающих скобок(круглых и угловых).
Тем самым, так как они обязаны быть в call, ret классах, и обязаны класть или снимать с стека ровно один символ, то язык не VPL. Если бы они не были в классах call, return то не получилось бы регулярно отслеживать вложенные структуры.
Формальное доказательство

# 2. Язык образцов в языке Рефал, которые распознают множества слов, обладающие префикс-свойством. Алфавит образцов: $\{e_1, e_2, s_1, s_2, a,b\}$. Здесь $e_i$ - переменные типа выражение, $s_i$ - переменные типа буква, $a,b$ - буквы.
Пусть в слове есть $e_i$. Тогда можно разделить слово на три части: $v_1 e_i v_2$.
Тогда можно $e_iv_2$ можно полностью включить в $e_i$. Значит нарушается префикс свойство. => в слове не допустимы $e_i$.

Если образец состоит из всех остальных символов, то он кодирует слова фиксированной длинны, для которых автоматически выполняется префикс свойство.
Поэтому язык можно записать с помощью регулярного выражения $(a|b|s_1|s_2)^*$.

> Очевидно, что для самого языка образцов префикс свойство не выполняется.
> Очевидно, что минимальный НКА состоит из двух состояний(принимающее и не принимающее) и совпадает с минимальным ДКА.

# 3. Язык атрибутной грамматики для Рефал-предложений:
```
[S] → [Pattern] = [Expr]             ; Expr.vars ⊆ Pattern.vars
[Pattern] → [Evar][Pattern]          ; Pattern0.vars := Pattern1.vars ∪ {Evar.name}
[Pattern] → [Const]                  ; Pattern.vars := ∅
[Const] → (a|b|c)∗                   ;
[Expr] →< [Function]_[Expr] > [Expr] ; Expr0.vars := Expr1.vars∪Expr2.vars 
[Expr] → [Expr][Expr]                ; Expr0.vars := Expr1.vars ∪ Expr2.vars
[Expr] → [Const]                     ; Expr.vars := ∅
[Expr] → [Evar]                      ; Expr.vars := {Evar.name}
[Evar] → e.[Num]                     ; Evar.name := e.(Num.str)
[Num] →1[Num]                        ; Num0.str := 1Num1.str
[Num] →0[Num]                        ; Num0.str := 0Num1.str
[Num] →ε                             ; Num.str := ε
```

**Текстовое описание атрибутной грамматики**
Атрибутная грамматика задает рефал предложения вида `Паттерн из переменных и констант = выражение`, где паттерн - набор переменных и констант `a,b,c`, а выражение может быть из функций, переменных и констант.
Функции записываются также как в первом задании
Переменные `e.n`, n - двоичное число обозначающее номер переменной.
Атрибутами задается свойство, что *в выражении можно использовать только переменные, использованные в паттерне.*

**Язык не является КС.**
Доказательство 1 *(aka очевидно)*
На лекции доказывалось, что свойство "переменная была объявлена ранее" не является КС. И поэтому язык не КС, так как в нем есть это свойство

Доказательство 2 *(aka лемма о накачке)*

Доказательство 3 *(aka анализ стратифицированных периодов)*