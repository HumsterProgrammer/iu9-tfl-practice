## номер 1
### Условие
---

Язык всех слов. порождаемых грамматикой  
$$
\begin{aligned}
S \to bSS\\
S \to aSa  \\
S \to b
\end{aligned}
$$
изначального нетерминала `Ѕ`, таких что в них максимальный отрезок только из букв `b` длиннее, чем совокупное число букв `а` во всем слове.
### Решение
---


Для начала, поймем, какие слова может порождать данная грамматика (не обращая внимания на ограничения). Грамматика состоит из трех правил:

1. $S \to bSS$
2. $S \to aSa$
3. $S \to b$

Рассмотрим несколько примеров слов, которые могут быть порождены этой грамматикой:

1. $S \to b$ — слово "b".
2. $S \to aSa \to aba$ — слово "aba".
3. $S \to bSS \to bbSSS \to bbbSSSS \to bbbb$ — слово "bbbb".

Теперь рассмотрим условие: максимальный отрезок только из букв `b` длиннее, чем совокупное число букв `а` во всем слове.

Примеры слов, удовлетворяющих условию:
- "b" (один отрезок "b", 0 букв "a")
- "bbbb" (один отрезок "bbbb", 0 букв "a")
- "abbba" (максимальный отрезок "bbb", 2 буквы "a")

Примеры слов, не удовлетворяющих условию:
- "aba" (максимальный отрезок "b", 2 буквы "a")
- "abbaa" (максимальный отрезок "bb", 3 буквы "a")

---

### Теорема Майхилла-Нероуда

Теорема Майхилла-Нероуда утверждает, что язык $L$ регулярен тогда и только тогда, когда множество классов эквивалентности по отношению суффиксной конгруэнтности конечно. 

 **Определение классов эквивалентности**:
 Рассмотрим слова вида $a^n$ для $n \geq 0$. Мы покажем, что для каждого $n$ слова $a^n$ принадлежат разным классам эквивалентности.

**Суффиксная конгруэнтность**:
Пусть $u = a^m$ и $v = a^n$ для $m \neq n$. Нам нужно показать, что $a^m \not\equiv a^n$.

**Проверка условия конгруэнтности**:
Рассмотрим слово $w = b^{2n+1} a^n$. Мы проверим, принадлежит ли $uw$ и $vw$ языку $L$.

 Слово $uw = a^m b^{2n+2} a^n$:
$$
     a^m b^{2n+1} a^n
$$
Это слово принадлежит языку $L$, если $m \leq n$. В противном случае, оно не принадлежит языку $L$.

Слово $vw = a^n b^{2n+1} a^n$:
$$
     a^n b^{2n+2} a^n
$$
Это слово принадлежит языку $L$, так как оно может быть порождено следующим образом:
$$
     S \to aSa \to aaSSa \to aaSbSSa \to \ldots \to a^n b^{2n+1} a^n
$$
Таким образом, $uw \in L$ тогда и только тогда, когда $m \leq n$, и $vw \in L$ тогда и только тогда, когда $n \leq n$. Следовательно, $a^m \not\equiv a^n$ для любых $m \neq n$.

**Бесконечное множество классов эквивалентности**:
Поскольку для каждого $n$ слова $a^n$ принадлежат разным классам эквивалентности, множество классов эквивалентности бесконечно.

Следовательно, по теореме Майхилла-Нероуда, язык, порождаемый данной грамматикой, не является регулярным, так как множество классов эквивалентности по отношению суффиксной конгруэнтности бесконечно

---
#### Применение леммы о накачке для контекстно-свободных языков
Лемма о накачке для контекстно-свободных языков утверждает, что для любого контекстно-свободного языка $L$ существует такое число $p$, что любое слово $s$ в $L$, длина которого не меньше $p$, можно разбить на пять частей $s = uvwxy$, такие что:
1. $vwx$ не больше $p$ символов,
2. $vx$ содержит по крайней мере один символ,
3. $uv^iwx^iy$ принадлежит $L$ для всех $i \geq 0$.

Для доказательства принадлежности языка к классу контекстно-свободных языков  используем лемму о накачке для контекстно-свободных языков. 

В данном случае, можно сказать, что любое слово, порождаемое данной грамматикой, можно накачивать через букву `b` положительно, используя правила $S \to b$ и $S \to bSS$. Это можно сделать в любом слове, т.к. существует только одно правило в грамматике, где справа только терминальные символы ($S \to b$), остальные правила ($S \to aSa; S \to bSS$) не могут завершить разбор слова, т.к. справа будет хотя бы 1 нетерминал. Но при отрицательной накачке мы выйдем из языка, т.к. нет правила  $S \to \varepsilon$. (аналогично для любой максимальной строки из $b$)
Если накачивать положительно $a$, то для достаточно большого $i$ мы выйдем из языка.

рассмотрим пересечение с регуляркой $ba^*b^*a^*b$
Получим $ba^nb^{2m+1}a^nb$ при накачке букв $a$ или перемычек (везде есть буквы $a$) мы выходим из грамматики 
При накачке крайних букв $b$ мы выходим из языка, т.к. нарушается 1 и 3 правила грамматики о нечётности количества букв `b` 
При отрицательной накачке букв в середине мы выходим из языка.

Таким образом язык не КС.

---
### Атрибутная грамматика
Давайте проверим, подходит ли ваша атрибутная грамматика для описания языка, порождаемого данной грамматикой.

#### Грамматика
$$
\begin{aligned}
S &\to bSS \\
S &\to aSa \\
S &\to b
\end{aligned}
$$

#### Атрибутная грамматика

**Атрибуты**:
- $S.numA$: Количество букв `a` в поддереве, порождаемом нетерминалом $S$.
- $S.begB$: Начало отрезка из букв `b` в поддереве, порождаемом нетерминалом $S$.
- $S.endB$: Конец отрезка из букв `b` в поддереве, порождаемом нетерминалом $S$.
- $S.maxB$: Максимальный отрезок из букв `b` в поддереве, порождаемом нетерминалом $S$.

**Правила вычисления атрибутов**:

Для правила $S \to b$: $$
     \begin{aligned}
     S.numA &= 0 \\
     S.begB &= 1 \\
     S.endB &= 1 \\
     S.maxB &= 1
     \end{aligned}
     $$
Для правила $S \to a S a$:
$$
 \begin{aligned}
 S.numA &= S_1.numA + 2 \\
 S.begB &= 0 \\
 S.endB &= 0 \\
 S.maxB &= S_1.maxB
 \end{aligned}
 $$

Для правила $S \to b S S$:
$$
 \begin{aligned}
 S.numA &= S_1.numA + S_2.numA \\
 S.begB &= 1 + S_1.begB \\
 S.endB &= S_2.endB \\
 temp1 &= 1 + S_1.begB \\
 temp2 &= S_1.maxB \\
 temp3 &= S_1.endB + S_2.begB \\
 temp4 &= S_2.maxB \\
 S.maxB &= \max(temp1, temp2, temp3, temp4)
 \end{aligned}
$$

**Корневое семантическое правило проверки** (применим его для стартового нетерминала $S'$):
   $$
   \text{if } (S.maxB \leq S.numA) \text{ then "не принимает слово" else "принимает"}
   $$
   Итоговая грамматика:
$$
\begin{aligned}
S'  & \quad \to S & \quad  &; S.maxB > S.numA\\
S & \quad \to b & \quad  &; S.numA = 0\text{, }S.begB = 1\text{, }S.endB = 1\text{, }S.maxB = 1 \\
S & \quad \to aSa  & \quad &;  S.numA = S_1.numA + 2 \text{, }S.begB = 0 \text{, } S.endB = 0 \text{, } S.maxB = S_1.maxB\\
S & \quad \to bSS  & \quad &; S.numA = S_1.numA + S_2.numA \text{, }S.begB = 1 + S_1.begB \text{, } S.endB = S_2.endB \text{, }\\
& \quad & \quad & temp1 = 1 + S_1.begB \text{, } temp2 = S_1.maxB \text{, } temp3 = S_1.endB + S_2.begB \text{, }\\
& \quad & \quad & temp4 = S_2.maxB \text{, } S.maxB = \max(temp1, temp2, temp3, temp4)
\end{aligned}
$$

---
### Префиксное свойство*
$$
\begin{aligned}
v' & \quad = abbba \\
S & \quad \to aSa \to abSSa \to abbba \\
w' & \quad = abbbababa \\
S & \quad \to aSa \to abSSa \to abbSSSa \to abbbaSaSa \to abbbababa
\end{aligned}
$$

---

## номер 2
### условие
---

Язык $L = \Big\{ w_{1} u u^R w_{2} \Big| |u|>0 \text{ \& } w_1 \neq uz_1 \text{ \& } w_2 \neq z_2u\text{ \& }u,w_1 ,w_2 \in \{a,b\}^* \Big\}$
### решение
---
Данный язык - расширенный язык палиндромов (который является КС-языком), он включает в себя все палиндромы ($w_1=w_2=\varepsilon$) и расширяет его, добавляя строки, которые не начинаются и не заканчиваются на палиндромную часть ($u$)

Также заметим, что все слова только из букв `a` или `b`$w: |w| > 3$ принадлежат языку

Чтобы проверить «$w_1$​ не заканчивается на $u$», **нам нужно знать** (в процессе чтения слева направо) «каково $u$?». Но $u$ определяется _только_ в середине (где $u u^R$ появляется). Получается нечто наподобие «двойного» сравнения: нужно с помощью одного стека одновременно «вычислять» $uu^R$ и следить, что перед этим блоком мы _не_ заканчиваемся на $u$. Такая ситуация часто приводит к тому, что язык требует «двух стеков», что не является КС.

Предположим, что язык не КС, для применения леммы о накачке нужно рассмотреть такие префиксы или суффиксы, которые при накачке могут нас вывести из языка (т.е. $w_1=uz_1$ или $w_2 = z_2u$) 

Рассмотрим слова вида $ababbabbb\dots\underset{u}{aa}\text{ } \underset{u^R}{aa}\text{ } ababbabbb\dots$ их можно накачать и не выйти из языка

---

#### рассмотрим слова языка

$w = az_1uu^Rz_2a$
$b \in z_1uu^Rz_2$
ели $z_1=z_2=\varepsilon \Rightarrow w \in L$

рассмотрим повторяющиеся интересные префиксы:
$(ba)^nabba$ или $(ab)^nabba$ 
рассмотрим пересечение с регуляркой $(ba)^*\text{ }\underset{u}{ab}\text{ }\underset{u^R}{ba}$ 
 $(ba)^n\text{ }\underset{u}{ab}\text{ }\underset{u^R}{ba}$ 
 мы можем накачивать `ba` не выходя из языка
 слово $babba\dots b^na\text{ }\underset{u}{ab}\text{ }\underset{u^R}{ba}$ также можно накачать
 слова типа $b^na^{n-1}\underset{u}{\underline{a^nb}}^nb^na^n$ 
 слова вида $a^nb^na^nb^n$ лежат в языке при $n \geq 2$
рассмотрим слова, у которых нечётный "палиндром" в центре из одного типа букв: $bab^{2n+1}ab$  он не подходит нам, рассмотрим похожий случай $\underset{u}{b}^n\text{ }\underset{u^R}{b}^n\text{ }ab^{2n+1}ab^{n-1}$ пересечём с $b^*ab^*ab^*$ , но тут по-прежнему можно  накачивать b в середине
 
---
### КС-свойства
По ощущениям язык не КС, попытаемся доказать это
рассмотрим "якоря" за которые можно зацепиться, всё зафиксировать и выйти из языка при накачке
$a^{2n}bba^{n} \cap a^*bba^*$
$v=a^nb$, что не подходит, нужно это отделить
$a^{2n}bbba^{n}\Rightarrow |v|_a=0$, т.к. нарушается условие префикса, но можно выбрать  $v=b$ и спокойно накачивать палиндромную часть
нужно отделить $a^n$ от палиндрома $b$ буквой $b$, но что-то тут не так, отделим палиндром из $a$ буквами $b$, заметим, что палиндром должен быть нечётным:
$$a^{2n}ba^{4n+3}ba^{n}$$
полученное слово пересечём с  $a^*ba^*ba^*$
$$
\underset{w_1}{\underline{a^{2n}ba}}\text{ }
\underset{v}{\underline{a^{2n+1}}}\text{ }
\underset{v^R}{\underline{a^{2n+1}}}\text{ }
\underset{w_2}{\underline{ba^{n}}}\text{ }
$$
при накачке данного слова выходим из языка, язык не КС ч. т. д.

---
### Префиксное свойство*
$$
\begin{aligned}
w' & \quad = \underset{w_1}{\varepsilon}\text{ } \underset{v}{a}\text{ }\underset{v^R}{a} \text{ }\underset{w_2}{\varepsilon}\\
v' & \quad = \underset{w_1}{aa}\text{ }\underset{v}{b}\text{ }\underset{v^R}{b}\text{ }\underset{w_2}{\varepsilon}
\end{aligned}
$$

---

## номер 3
### условие
----

Язык описывающийся следующей атрибутной грамматикой:
$$
\begin{aligned}
& S \to aS'a |bS'b & \quad; S'.inh\_attr := 1\\
& S' \to aS'a |bS'b & \quad; S'_1.inh\_attr := S'_0.inh\_attr + 1 \\
& S' \to T & \quad; T'.inh\_attr := S'.inh\_attr \\
& T  \to aT|bT|cT & \quad; T_1.inh\_attr := T_0.inh\_attr - 1\\
&T \to cT & \quad; T_1.inh\_attr := T_0.inh\_attr + 1\\
& T  \to cT & \quad;  T_1.inh\_attr := T_0.inh\_attr \\
& T \to \varepsilon & \quad;T.inh\_attr==0
\end{aligned}
$$
### решение
---
#### Правила грамматики и их атрибуты
Правило: $S \to aS'a \mid bS'b$
Атрибут: $S'.inh\_attr := 1$
Описание: Начальный символ $S$ порождает строки, начинающиеся и заканчивающиеся одинаковыми символами $a$ или $b$. Атрибут $S'.inh\_attr$ инициализируется значением 1.

Правило: $S' \to aS'a \mid bS'b$
Атрибут: $S'_1.inh\_attr := S'_0.inh\_attr + 1$
Описание: Символ $S'$ может порождать строки, начинающиеся и заканчивающиеся одинаковыми символами $a$ или $b$. Атрибут $S'_1.inh\_attr$ увеличивается на 1 по сравнению с предыдущим значением.

Правило: $S' \to T$
Атрибут: $T'.inh\_attr := S'.inh\_attr$
Описание: Символ $S'$ может быть заменен на $T$, при этом атрибут $T'.inh\_attr$ наследует значение атрибута $S'.inh\_attr$.

Правило: $T \to aT \mid bT \mid cT$
Атрибут: $T_1.inh\_attr := T_0.inh\_attr - 1$
Описание: Символ $T$ может порождать строки, содержащие символы $a$, $b$ или $c$. Атрибут $T_1.inh\_attr$ уменьшается на 1 по сравнению с предыдущим значением.

Правило: $T \to cT$
Атрибут: $T_1.inh\_attr := T_0.inh\_attr + 1$
Описание: Символ $T$ может порождать строки, содержащие символ $c$. Атрибут $T_1.inh\_attr$ увеличивается на 1 по сравнению с предыдущим значением.

Правило: $T \to cT$
Атрибут: $T_1.inh\_attr := T_0.inh\_attr$
Описание: Символ $T$ может порождать строки, содержащие символ $c$. Атрибут $T_1.inh\_attr$ остается неизменным.

Правило: $T \to \varepsilon$
Атрибут: $T.inh\_attr == 0$
Описание: Символ $T$ может быть заменен на пустой символ $\varepsilon$, если атрибут $T.inh\_attr$ равен 0.

---

$$ 
\begin{aligned}
L = \Big\{w v w^R \Big| w \in \{a,b\}^+ \text{ \& } v \in \{a,b,c\}^+ \text{ \& } -|v|_c \leq |w| - |v|_a -|v|_b \leq |v|_c \Big\}
\end{aligned}
$$

---

Строка $w v w^R$ состоит из трех частей: $w$, $v$ и $w^R$ (обратная строка $w$).

$w$ — это строка, состоящая из символов $a$ и $b$, и её длина больше нуля ($w \in \{a, b\}^+$).
$v$ — это строка, состоящая из символов $a$, $b$ и $c$, и её длина также больше нуля ($v \in \{a, b, c\}^+$).

Сумма количества символов $a$ и $b$ в $v$ плюс $n$ равна длине строки $w$ (или $|v|_a + |v|_b + n = |w|$).
$n$ — это количество символов $c$ в строке $v$, и оно должно быть меньше или равно количеству символов $c$ в $v$ (или $n \leq |w|_c$).
#### Проверка класса языка (ниже приведена идея решения)

Для доказательства того, что язык $L$ не является контекстно-свободным, используя лемму о накачке, нужно рассмотреть все возможные накачки строки $s = w v w^R$, где $w \in \{a, b\}^+$ и $v \in \{a, b, c\}^+$.

Лемма о накачке для контекстно-свободных языков утверждает, что для любого контекстно-свободного языка $L$ существует такое число $p$ (накачка), что любая строка $s$ в $L$ длиной не менее $p$ может быть разложена на пять частей:

$$
s = uvwxy
$$

такие, что:

1. $v$ и $x$ вместе содержат не более $p$ символов.
2. $v$ и $x$ не пустые.
3. $uv^iwx^iy$ принадлежит языку для любого $i \geq 0$.


Рассмотрим строку $s = w v w^R$, где $w \in \{a, b\}^+$ и $v \in \{a, b, c\}^+$. Предположим, что $L$ является контекстно-свободным языком, и пусть $p$ — накачка. Рассмотрим строку $s = w v w^R$ длиной не менее $p$. Разложим $s$ на пять частей:

$$
s = uvwxy
$$

где $u$, $v$, $w$, $x$ и $y$ — это подстроки строки $s$.

**Случай 1: $v$ и $x$ полностью внутри $w$ или $w^R$**
   Если $v$ и $x$ находятся полностью внутри $w$ или $w^R$, то накачивание $v$ и $x$ нарушит симметрию $w$ и $w^R$. Например, если $v$ и $x$ находятся внутри $w$, то накачивание $v$ и $x$ изменит количество символов $a$ и $b$ в $w$, что нарушит условие $w = w^R$. (лишние символы нельзя "разместить" в $v$ т.к. нарушиться атрибутное условие)

 **Случай 2: $v$ и $x$ полностью внутри $v$**
   Если $v$ и $x$ находятся полностью внутри $v$, то накачивание $v$ и $x$ изменит количество символов $a$, $b$ и $c$ в $v$. Однако, условие $|v|_a + |v|_b + n = |w|$ и $n \leq |w|_c$ не будет соблюдаться, так как количество символов $a$ и $b$ в $v$ изменится, что нарушит условие.

 **Случай 3: $v$ и $x$ пересекают границы между $w$, $v$ и $w^R$**
   Если $v$ и $x$ пересекают границы между $w$, $v$ и $w^R$, то накачивание $v$ и $x$ нарушит структуру строки $w v w^R$. Например, если $v$ и $x$ пересекают границу между $w$ и $v$, то накачивание $v$ и $x$ изменит количество символов $a$ и $b$ в $w$, что нарушит условие $w = w^R$. 

Во всех возможных случаях накачки строки $s = w v w^R$ накачивание $v$ и $x$ нарушает условия языка $L$. Следовательно, язык $L$ не является контекстно-свободным.

---
### Префиксное свойство*
$$
\begin{aligned}
v' & \quad = \underset{w}{a}\text{ }\underset{v}{b}\text{ }\underset{w^R}{a}\\
w' & \quad = \underset{w}{aba}\text{ }\underset{v}{ccc}\text{ }\underset{w^R}{aba}
\end{aligned}
$$

---
